<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BST Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;
        const Play = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Trash2 = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;
        const Search = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>;
        const RotateCcw = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>;

        const BSTVisualizer = () => {
          const [tree, setTree] = useState(null);
          const [inputValue, setInputValue] = useState('');
          const [highlightedNodes, setHighlightedNodes] = useState([]);
          const [message, setMessage] = useState('');
          const [traversalType, setTraversalType] = useState('inorder');

          const insertNode = (root, value) => {
            if (!root) {
              return { value, left: null, right: null, x: 0, y: 0 };
            }

            if (value < root.value) {
              return { ...root, left: insertNode(root.left, value) };
            } else if (value > root.value) {
              return { ...root, right: insertNode(root.right, value) };
            }
            return root;
          };

          const searchNode = (root, value, path = []) => {
            if (!root) return { found: false, path };
            
            path.push(root.value);
            
            if (root.value === value) {
              return { found: true, path };
            }
            
            if (value < root.value) {
              return searchNode(root.left, value, path);
            } else {
              return searchNode(root.right, value, path);
            }
          };

          const findMin = (node) => {
            while (node.left) {
              node = node.left;
            }
            return node;
          };

          const deleteNode = (root, value) => {
            if (!root) return null;

            if (value < root.value) {
              return { ...root, left: deleteNode(root.left, value) };
            } else if (value > root.value) {
              return { ...root, right: deleteNode(root.right, value) };
            } else {
              if (!root.left && !root.right) return null;
              if (!root.left) return root.right;
              if (!root.right) return root.left;

              const minRight = findMin(root.right);
              return {
                ...root,
                value: minRight.value,
                right: deleteNode(root.right, minRight.value)
              };
            }
          };

          const calculatePositions = (node, x = 400, y = 50, spacing = 150) => {
            if (!node) return null;

            const newNode = { ...node, x, y };

            if (node.left) {
              newNode.left = calculatePositions(node.left, x - spacing, y + 80, spacing / 2);
            }
            if (node.right) {
              newNode.right = calculatePositions(node.right, x + spacing, y + 80, spacing / 2);
            }

            return newNode;
          };

          const handleInsert = () => {
            const value = parseInt(inputValue);
            if (isNaN(value)) {
              setMessage('❌ Please enter a valid number');
              return;
            }

            const result = searchNode(tree, value);
            if (result.found) {
              setMessage(`❌ ${value} already exists in the tree`);
              setInputValue('');
              return;
            }

            const newTree = insertNode(tree, value);
            const positioned = calculatePositions(newTree);
            setTree(positioned);
            setMessage(`✅ Inserted ${value}`);
            setHighlightedNodes([value]);
            setInputValue('');
            setTimeout(() => setHighlightedNodes([]), 2000);
          };

          const handleSearch = () => {
            const value = parseInt(inputValue);
            if (isNaN(value)) {
              setMessage('❌ Please enter a valid number');
              return;
            }

            const result = searchNode(tree, value);
            setHighlightedNodes(result.path);
            setMessage(result.found ? `✅ Found ${value}` : `❌ ${value} not found`);
            setInputValue('');
            setTimeout(() => setHighlightedNodes([]), 3000);
          };

          const handleDelete = () => {
            const value = parseInt(inputValue);
            if (isNaN(value)) {
              setMessage('❌ Please enter a valid number');
              return;
            }

            const result = searchNode(tree, value);
            if (!result.found) {
              setMessage(`❌ ${value} not found in tree`);
              setInputValue('');
              return;
            }

            const newTree = deleteNode(tree, value);
            const positioned = calculatePositions(newTree);
            setTree(positioned);
            setMessage(`✅ Deleted ${value}`);
            setHighlightedNodes(result.path);
            setInputValue('');
            setTimeout(() => setHighlightedNodes([]), 2000);
          };

          const handleReset = () => {
            setTree(null);
            setHighlightedNodes([]);
            setMessage('🔄 Tree cleared');
            setInputValue('');
          };

          const getTraversal = (node, type, result = []) => {
            if (!node) return result;

            if (type === 'preorder') {
              result.push(node.value);
              getTraversal(node.left, type, result);
              getTraversal(node.right, type, result);
            } else if (type === 'inorder') {
              getTraversal(node.left, type, result);
              result.push(node.value);
              getTraversal(node.right, type, result);
            } else if (type === 'postorder') {
              getTraversal(node.left, type, result);
              getTraversal(node.right, type, result);
              result.push(node.value);
            }

            return result;
          };

          const showTraversal = () => {
            if (!tree) {
              setMessage('❌ Tree is empty');
              return;
            }

            const result = getTraversal(tree, traversalType);
            setMessage(`${traversalType.charAt(0).toUpperCase() + traversalType.slice(1)}: ${result.join(' → ')}`);

            result.forEach((val, idx) => {
              setTimeout(() => {
                setHighlightedNodes([val]);
              }, idx * 500);
            });

            setTimeout(() => setHighlightedNodes([]), result.length * 500 + 1000);
          };

          const renderNode = (node) => {
            if (!node) return null;

            const isHighlighted = highlightedNodes.includes(node.value);

            return (
              <g key={`${node.value}-${node.x}-${node.y}`}>
                {node.left && (
                  <line
                    x1={node.x}
                    y1={node.y}
                    x2={node.left.x}
                    y2={node.left.y}
                    stroke="#64748b"
                    strokeWidth="2"
                  />
                )}
                {node.right && (
                  <line
                    x1={node.x}
                    y1={node.y}
                    x2={node.right.x}
                    y2={node.right.y}
                    stroke="#64748b"
                    strokeWidth="2"
                  />
                )}

                <circle
                  cx={node.x}
                  cy={node.y}
                  r="25"
                  fill={isHighlighted ? '#10b981' : '#3b82f6'}
                  stroke="#1e40af"
                  strokeWidth="3"
                  style={{ transition: 'all 0.3s ease' }}
                />
                <text
                  x={node.x}
                  y={node.y}
                  textAnchor="middle"
                  dy=".35em"
                  fill="white"
                  fontSize="16"
                  fontWeight="bold"
                >
                  {node.value}
                </text>

                {node.left && renderNode(node.left)}
                {node.right && renderNode(node.right)}
              </g>
            );
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8">
              <div className="max-w-6xl mx-auto">
                <div className="text-center mb-8">
                  <h1 className="text-4xl md:text-5xl font-bold text-white mb-2">
                    🌳 Binary Search Tree Visualizer
                  </h1>
                  <p className="text-slate-300 text-lg">
                    Interactive BST with Insert/Delete/Search & Traversal
                  </p>
                </div>

                <div className="bg-white rounded-xl shadow-2xl p-6 mb-6">
                  <div className="flex flex-col md:flex-row gap-4 items-stretch md:items-end mb-6">
                    <div className="flex-1 min-w-[200px]">
                      <label className="block text-sm font-semibold text-gray-700 mb-2">
                        Enter Value (Number)
                      </label>
                      <input
                        type="number"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && handleInsert()}
                        placeholder="e.g., 50"
                        className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      <button
                        onClick={handleInsert}
                        className="flex-1 md:flex-none px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 font-semibold flex items-center justify-center gap-2 transition-all shadow-lg hover:shadow-xl"
                      >
                        <Play /> Insert
                      </button>

                      <button
                        onClick={handleSearch}
                        className="flex-1 md:flex-none px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold flex items-center justify-center gap-2 transition-all shadow-lg hover:shadow-xl"
                      >
                        <Search /> Search
                      </button>

                      <button
                        onClick={handleDelete}
                        className="flex-1 md:flex-none px-6 py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 font-semibold flex items-center justify-center gap-2 transition-all shadow-lg hover:shadow-xl"
                      >
                        <Trash2 /> Delete
                      </button>

                      <button
                        onClick={handleReset}
                        className="flex-1 md:flex-none px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-semibold flex items-center justify-center gap-2 transition-all shadow-lg hover:shadow-xl"
                      >
                        <RotateCcw /> Reset
                      </button>
                    </div>
                  </div>

                  <div className="flex flex-col md:flex-row gap-4 items-stretch md:items-center pt-4 border-t-2">
                    <label className="text-sm font-semibold text-gray-700">
                      Tree Traversal:
                    </label>
                    <select
                      value={traversalType}
                      onChange={(e) => setTraversalType(e.target.value)}
                      className="px-4 py-2 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 font-medium"
                    >
                      <option value="inorder">Inorder (L → Root → R)</option>
                      <option value="preorder">Preorder (Root → L → R)</option>
                      <option value="postorder">Postorder (L → R → Root)</option>
                    </select>
                    <button
                      onClick={showTraversal}
                      className="px-6 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 font-semibold transition-all shadow-lg hover:shadow-xl"
                    >
                      Visualize Traversal
                    </button>
                  </div>

                  {message && (
                    <div className={`mt-4 p-4 rounded-lg font-medium text-center ${
                      message.includes('✅') ? 'bg-green-100 text-green-800 border-2 border-green-300' :
                      message.includes('❌') ? 'bg-red-100 text-red-800 border-2 border-red-300' :
                      'bg-blue-100 text-blue-800 border-2 border-blue-300'
                    }`}>
                      {message}
                    </div>
                  )}
                </div>

                <div className="bg-white rounded-xl shadow-2xl p-6 overflow-x-auto">
                  <svg width="800" height="500" className="mx-auto">
                    {tree ? (
                      renderNode(tree)
                    ) : (
                      <text x="400" y="250" textAnchor="middle" fill="#94a3b8" fontSize="20" fontWeight="500">
                        Tree is empty. Insert a value to begin! 🌱
                      </text>
                    )}
                  </svg>
                </div>

                <div className="mt-6 bg-gradient-to-r from-blue-600 to-purple-600 rounded-xl shadow-2xl p-6 text-white">
                  <h3 className="text-2xl font-bold mb-4">📚 Quick Guide:</h3>
                  <div className="grid md:grid-cols-2 gap-4">
                    <div className="bg-white/10 rounded-lg p-4 backdrop-blur">
                      <strong className="text-yellow-300">🔵 Insert:</strong> Add nodes (no duplicates allowed)
                    </div>
                    <div className="bg-white/10 rounded-lg p-4 backdrop-blur">
                      <strong className="text-green-300">🔍 Search:</strong> Find values with highlighted path
                    </div>
                    <div className="bg-white/10 rounded-lg p-4 backdrop-blur">
                      <strong className="text-red-300">🗑️ Delete:</strong> Remove any node from tree
                    </div>
                    <div className="bg-white/10 rounded-lg p-4 backdrop-blur">
                      <strong className="text-purple-300">🔄 Traversal:</strong> Animate tree traversal orders
                    </div>
                  </div>
                  <div className="mt-4 bg-white/10 rounded-lg p-4 backdrop-blur">
                    <strong className="text-yellow-300">💡 Try this:</strong> Insert 50, 30, 70, 20, 40, 60, 80 for a perfect balanced tree!
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<BSTVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>